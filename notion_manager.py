"""\nNotion Database Manager\n\nManages Notion database operations including duplicate detection and page creation.\nDesigned for the \"Client Hunt\" database integration.\n\nAuthor: Rahi Khan (Dropout Studio)\nLicense: MIT\n"""\n\nimport time\nimport logging\nfrom typing import Dict, List, Set, Optional\n\nfrom notion_client import Client\nfrom notion_client.errors import APIResponseError\n\n\nclass NotionDatabaseManager:\n    \"\"\"\n    Manages Notion database operations for Instagram lead tracking.\n    \n    Features:\n    - Duplicate detection with caching\n    - Batch page creation\n    - Rate limiting (3 requests/second)\n    - Comprehensive error handling\n    \n    Example:\n        >>> manager = NotionDatabaseManager(token=\"secret_xxx\", database_id=\"xxx\")\n        >>> duplicates = manager.get_all_existing_usernames()\n        >>> manager.create_page(\"nike\", \"https://instagram.com/nike\")\n    \"\"\"\n    \n    RATE_LIMIT_DELAY = 0.35  # Seconds between requests (3 req/sec)\n    \n    def __init__(self, token: str, database_id: str):\n        \"\"\"\n        Initialize Notion database manager.\n        \n        Args:\n            token: Notion integration token\n            database_id: Notion database ID (with or without dashes)\n        \"\"\"\n        self.client = Client(auth=token)\n        self.database_id = self._normalize_id(database_id)\n        self.logger = logging.getLogger(__name__)\n        self._last_request_time = 0\n        self._existing_usernames_cache: Optional[Set[str]] = None\n        \n        # Verify connection\n        self._verify_connection()\n    \n    def _normalize_id(self, id_string: str) -> str:\n        \"\"\"\n        Normalize Notion ID (remove dashes if present).\n        \n        Args:\n            id_string: Notion ID with or without dashes\n            \n        Returns:\n            Normalized ID string\n        \"\"\"\n        return id_string.replace(\"-\", \"\")\n    \n    def _enforce_rate_limit(self):\n        \"\"\"Enforce rate limiting between Notion API requests.\"\"\"\n        if self._last_request_time > 0:\n            elapsed = time.time() - self._last_request_time\n            if elapsed < self.RATE_LIMIT_DELAY:\n                time.sleep(self.RATE_LIMIT_DELAY - elapsed)\n        self._last_request_time = time.time()\n    \n    def _verify_connection(self):\n        \"\"\"\n        Verify connection to Notion database.\n        \n        Raises:\n            Exception: If connection fails\n        \"\"\"\n        try:\n            self._enforce_rate_limit()\n            db = self.client.databases.retrieve(database_id=self.database_id)\n            db_title = db.get(\"title\", [{}])[0].get(\"plain_text\", \"Unknown\")\n            self.logger.info(f\"✓ Connected to database: {db_title}\")\n        except APIResponseError as e:\n            self.logger.error(f\"Failed to connect to Notion database: {e}\")\n            raise Exception(f\"Could not connect to Notion database: {e}\")\n        except Exception as e:\n            self.logger.error(f\"Unexpected error connecting to Notion: {e}\")\n            raise\n    \n    def get_all_existing_usernames(self, force_refresh: bool = False) -> Set[str]:\n        \"\"\"\n        Fetch all existing usernames from the database.\n        Uses caching to avoid repeated API calls.\n        \n        Args:\n            force_refresh: Force refresh cache even if already loaded\n            \n        Returns:\n            Set of lowercase usernames already in database\n        \"\"\"\n        # Return cached values if available\n        if self._existing_usernames_cache is not None and not force_refresh:\n            self.logger.debug(f\"Using cached usernames ({len(self._existing_usernames_cache)} entries)\")\n            return self._existing_usernames_cache\n        \n        usernames = set()\n        has_more = True\n        start_cursor = None\n        page_count = 0\n        \n        self.logger.info(\"Fetching existing usernames from Notion...\")\n        \n        try:\n            while has_more:\n                self._enforce_rate_limit()\n                \n                # Query database with pagination\n                query_params = {\n                    \"database_id\": self.database_id,\n                    \"page_size\": 100  # Maximum allowed\n                }\n                \n                if start_cursor:\n                    query_params[\"start_cursor\"] = start_cursor\n                \n                response = self.client.databases.query(**query_params)\n                \n                # Extract usernames from \"Brand Name\" title field\n                for page in response.get(\"results\", []):\n                    props = page.get(\"properties\", {})\n                    brand_name_prop = props.get(\"Brand Name\", {})\n                    \n                    # Extract title text\n                    title_list = brand_name_prop.get(\"title\", [])\n                    if title_list:\n                        username = title_list[0].get(\"plain_text\", \"\").strip().lower()\n                        if username:\n                            usernames.add(username)\n                \n                # Check pagination\n                has_more = response.get(\"has_more\", False)\n                start_cursor = response.get(\"next_cursor\")\n                page_count += 1\n                \n                self.logger.debug(f\"Fetched page {page_count}, total usernames: {len(usernames)}\")\n        \n        except APIResponseError as e:\n            self.logger.error(f\"Error fetching existing usernames: {e}\")\n            raise\n        except Exception as e:\n            self.logger.error(f\"Unexpected error fetching usernames: {e}\", exc_info=True)\n            raise\n        \n        self.logger.info(f\"✓ Found {len(usernames)} existing usernames in database\")\n        \n        # Cache the results\n        self._existing_usernames_cache = usernames\n        \n        return usernames\n    \n    def check_duplicate_username(self, username: str) -> bool:\n        \"\"\"\n        Check if username already exists in database.\n        \n        Args:\n            username: Instagram username to check\n            \n        Returns:\n            True if username exists, False otherwise\n        \"\"\"\n        existing = self.get_all_existing_usernames()\n        return username.lower() in existing\n    \n    def create_page(\n        self,\n        username: str,\n        instagram_url: str,\n        status: str = \"Didn't Approach\",\n        business_types: Optional[List[str]] = None,\n        payment_system: Optional[str] = None,\n        amount: Optional[float] = None\n    ) -> Dict:\n        \"\"\"\n        Create a new page in the Notion database.\n        \n        Args:\n            username: Instagram username (required)\n            instagram_url: Full Instagram URL (required)\n            status: Status value (default: \"Didn't Approach\")\n            business_types: List of business type tags (optional)\n            payment_system: Payment system status (optional)\n            amount: Project amount (optional)\n            \n        Returns:\n            Dictionary with creation result:\n            {\n                'success': bool,\n                'page_id': Optional[str],\n                'url': Optional[str],\n                'error': Optional[str]\n            }\n        \"\"\"\n        result = {\n            'success': False,\n            'page_id': None,\n            'url': None,\n            'error': None\n        }\n        \n        try:\n            self._enforce_rate_limit()\n            \n            # Build properties\n            properties = {\n                \"Brand Name\": {\n                    \"title\": [\n                        {\n                            \"text\": {\n                                \"content\": username\n                            }\n                        }\n                    ]\n                },\n                \"Social Media Account\": {\n                    \"url\": instagram_url\n                },\n                \"Status\": {\n                    \"status\": {\n                        \"name\": status\n                    }\n                }\n            }\n            \n            # Add optional properties if provided\n            if business_types:\n                properties[\"Business Type\"] = {\n                    \"multi_select\": [{\"name\": bt} for bt in business_types]\n                }\n            \n            if payment_system:\n                properties[\"Payment System\"] = {\n                    \"status\": {\n                        \"name\": payment_system\n                    }\n                }\n            \n            if amount is not None:\n                properties[\"Amount\"] = {\n                    \"number\": amount\n                }\n            \n            # Create the page\n            page = self.client.pages.create(\n                parent={\"database_id\": self.database_id},\n                properties=properties\n            )\n            \n            result['success'] = True\n            result['page_id'] = page.get(\"id\")\n            result['url'] = page.get(\"url\")\n            \n            self.logger.info(f\"✓ Created page for @{username}\")\n            \n            # Invalidate cache since we added a new entry\n            if self._existing_usernames_cache is not None:\n                self._existing_usernames_cache.add(username.lower())\n        \n        except APIResponseError as e:\n            result['error'] = f\"Notion API error: {e}\"\n            self.logger.error(f\"Failed to create page for @{username}: {e}\")\n        \n        except Exception as e:\n            result['error'] = f\"Unexpected error: {str(e)}\"\n            self.logger.error(f\"Unexpected error creating page for @{username}: {e}\", exc_info=True)\n        \n        return result\n    \n    def batch_create_pages(\n        self,\n        validated_accounts: List[Dict],\n        skip_duplicates: bool = True\n    ) -> Dict[str, int]:\n        \"\"\"\n        Create multiple pages in batch.\n        \n        Args:\n            validated_accounts: List of dicts with 'username' and 'url' keys\n            skip_duplicates: Skip usernames that already exist (default: True)\n            \n        Returns:\n            Statistics dictionary:\n            {\n                'total': int,           # Total accounts processed\n                'created': int,         # Successfully created\n                'failed': int,          # Failed to create\n                'skipped': int,         # Skipped (duplicates)\n                'errors': List[str]     # Error messages\n            }\n        \"\"\"\n        stats = {\n            'total': len(validated_accounts),\n            'created': 0,\n            'failed': 0,\n            'skipped': 0,\n            'errors': []\n        }\n        \n        # Pre-fetch existing usernames for duplicate checking\n        existing = set()\n        if skip_duplicates:\n            try:\n                existing = self.get_all_existing_usernames()\n            except Exception as e:\n                self.logger.warning(f\"Could not fetch existing usernames: {e}\")\n        \n        self.logger.info(f\"Starting batch creation of {stats['total']} accounts\")\n        \n        for i, account in enumerate(validated_accounts, 1):\n            username = account.get('username', '')\n            url = account.get('url', '')\n            \n            if not username or not url:\n                stats['failed'] += 1\n                stats['errors'].append(f\"Invalid account data: {account}\")\n                continue\n            \n            # Check duplicates\n            if skip_duplicates and username.lower() in existing:\n                self.logger.info(f\"[{i}/{stats['total']}] Skipping duplicate: @{username}\")\n                stats['skipped'] += 1\n                continue\n            \n            # Create page\n            self.logger.info(f\"[{i}/{stats['total']}] Creating page for @{username}...\")\n            result = self.create_page(username, url)\n            \n            if result['success']:\n                stats['created'] += 1\n            else:\n                stats['failed'] += 1\n                error_msg = f\"@{username}: {result['error']}\"\n                stats['errors'].append(error_msg)\n        \n        self.logger.info(\n            f\"Batch creation complete: \"\n            f\"{stats['created']} created, \"\n            f\"{stats['failed']} failed, \"\n            f\"{stats['skipped']} skipped\"\n        )\n        \n        return stats\n    \n    def get_database_info(self) -> Dict:\n        \"\"\"\n        Get information about the database.\n        \n        Returns:\n            Database metadata dictionary\n        \"\"\"\n        try:\n            self._enforce_rate_limit()\n            db = self.client.databases.retrieve(database_id=self.database_id)\n            \n            return {\n                'id': db.get('id'),\n                'title': db.get(\"title\", [{}])[0].get(\"plain_text\", \"Unknown\"),\n                'url': db.get('url'),\n                'properties': list(db.get('properties', {}).keys())\n            }\n        except Exception as e:\n            self.logger.error(f\"Error getting database info: {e}\")\n            return {}\n\n\n# Example usage\nif __name__ == \"__main__\":\n    import os\n    from dotenv import load_dotenv\n    \n    # Configure logging\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n    )\n    \n    # Load environment variables\n    load_dotenv()\n    \n    token = os.getenv(\"NOTION_TOKEN\")\n    database_id = os.getenv(\"NOTION_DATABASE_ID\")\n    \n    if not token or not database_id:\n        print(\"❌ Error: NOTION_TOKEN and NOTION_DATABASE_ID must be set in .env\")\n        exit(1)\n    \n    print(\"Notion Database Manager - Test Run\")\n    print(\"=\" * 60)\n    \n    try:\n        manager = NotionDatabaseManager(token, database_id)\n        \n        # Get database info\n        info = manager.get_database_info()\n        print(f\"\\nDatabase: {info.get('title')}\")\n        print(f\"Properties: {', '.join(info.get('properties', []))}\")\n        \n        # Get existing usernames\n        existing = manager.get_all_existing_usernames()\n        print(f\"\\nExisting entries: {len(existing)}\")\n        \n        # Test duplicate check\n        test_username = \"test_account_123\"\n        is_duplicate = manager.check_duplicate_username(test_username)\n        print(f\"\\nIs '{test_username}' a duplicate? {is_duplicate}\")\n        \n        print(\"\\n✓ Test completed successfully\")\n        \n    except Exception as e:\n        print(f\"\\n❌ Test failed: {e}\")\n