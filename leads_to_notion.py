"""\nInstagram Leads to Notion Sync\n\nMain orchestration script for validating Instagram usernames and syncing to Notion.\nHandles duplicate detection, validation, and batch operations.\n\nAuthor: Rahi Khan (Dropout Studio)\nLicense: MIT\n"""\n\nimport os\nimport sys\nimport json\nimport logging\nimport argparse\nfrom pathlib import Path\nfrom datetime import datetime\nfrom typing import List, Dict, Tuple, Set\n\nfrom dotenv import load_dotenv\n\nfrom instagram_validator import InstagramValidator\nfrom notion_manager import NotionDatabaseManager\n\n\ndef setup_logging(verbose: bool = False):\n    \"\"\"\n    Configure logging for the application.\n    \n    Args:\n        verbose: Enable debug logging\n    \"\"\"\n    level = logging.DEBUG if verbose else logging.INFO\n    \n    # Console handler\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(level)\n    console_formatter = logging.Formatter(\n        '%(asctime)s - %(levelname)s - %(message)s',\n        datefmt='%H:%M:%S'\n    )\n    console_handler.setFormatter(console_formatter)\n    \n    # File handler for errors\n    log_dir = Path(\"validation_results\")\n    log_dir.mkdir(exist_ok=True)\n    \n    file_handler = logging.FileHandler(\n        log_dir / f\"sync_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log\"\n    )\n    file_handler.setLevel(logging.DEBUG)\n    file_formatter = logging.Formatter(\n        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n    )\n    file_handler.setFormatter(file_formatter)\n    \n    # Root logger\n    root_logger = logging.getLogger()\n    root_logger.setLevel(logging.DEBUG)\n    root_logger.addHandler(console_handler)\n    root_logger.addHandler(file_handler)\n\n\ndef load_usernames_from_markdown(file_path: Path) -> List[str]:\n    \"\"\"\n    Load Instagram usernames from a markdown file.\n    Expects one username per line, ignores empty lines and comments.\n    \n    Args:\n        file_path: Path to markdown file\n        \n    Returns:\n        List of usernames\n        \n    Raises:\n        FileNotFoundError: If file doesn't exist\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    \n    if not file_path.exists():\n        raise FileNotFoundError(f\"Input file not found: {file_path}\")\n    \n    usernames = []\n    \n    with open(file_path, 'r', encoding='utf-8') as f:\n        for line_num, line in enumerate(f, 1):\n            # Strip whitespace\n            line = line.strip()\n            \n            # Skip empty lines and markdown headers\n            if not line or line.startswith('#'):\n                continue\n            \n            # Remove common markdown list markers\n            line = line.lstrip('-*‚Ä¢').strip()\n            \n            # Remove @ symbol if present\n            line = line.lstrip('@')\n            \n            # Skip if still empty\n            if not line:\n                continue\n            \n            # Take only the first word (in case of comments)\n            username = line.split()[0]\n            \n            # Basic validation\n            if username and len(username) > 0:\n                usernames.append(username)\n    \n    logger.info(f\"Loaded {len(usernames)} usernames from {file_path.name}\")\n    \n    return usernames\n\n\ndef deduplicate_batch(usernames: List[str]) -> Tuple[List[str], int]:\n    \"\"\"\n    Remove duplicate usernames from the list (case-insensitive).\n    \n    Args:\n        usernames: List of usernames\n        \n    Returns:\n        Tuple of (unique_usernames, duplicate_count)\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    \n    original_count = len(usernames)\n    seen = set()\n    unique = []\n    \n    for username in usernames:\n        username_lower = username.lower()\n        if username_lower not in seen:\n            seen.add(username_lower)\n            unique.append(username)\n    \n    duplicate_count = original_count - len(unique)\n    \n    if duplicate_count > 0:\n        logger.info(f\"Removed {duplicate_count} duplicate(s) from batch\")\n    \n    return unique, duplicate_count\n\n\ndef save_validation_results(results: List[Dict], output_dir: Path):\n    \"\"\"\n    Save validation results to JSON file.\n    \n    Args:\n        results: List of validation result dictionaries\n        output_dir: Output directory\n    \"\"\"\n    output_dir.mkdir(exist_ok=True)\n    \n    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n    output_file = output_dir / f\"validation_results_{timestamp}.json\"\n    \n    with open(output_file, 'w', encoding='utf-8') as f:\n        json.dump(results, f, indent=2)\n    \n    logging.info(f\"Validation results saved to: {output_file}\")\n\n\ndef generate_sync_report(stats: Dict, output_path: Path):\n    \"\"\"\n    Generate human-readable markdown report.\n    \n    Args:\n        stats: Statistics dictionary\n        output_path: Path to save report\n    \"\"\"\n    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n    \n    report = f\"\"\"# Instagram to Notion Sync Report\n\n**Generated:** {timestamp}\n\n## Summary Statistics\n\n| Metric | Count |\n|--------|------:|\n| Total Usernames | {stats.get('total_input', 0)} |\n| Batch Duplicates | {stats.get('duplicates_batch', 0)} |\n| Notion Duplicates | {stats.get('duplicates_notion', 0)} |\n| Validated | {stats.get('validated', 0)} |\n| Valid Accounts | {stats.get('valid_accounts', 0)} |\n| Invalid Accounts | {stats.get('invalid_accounts', 0)} |\n| Added to Notion | {stats.get('added_to_notion', 0)} |\n| Failed to Add | {stats.get('failed_to_add', 0)} |\n\n## Processing Details\n\n### Duplicate Detection\n- **{stats.get('duplicates_batch', 0)}** duplicates found within input batch\n- **{stats.get('duplicates_notion', 0)}** usernames already exist in Notion database\n\n### Instagram Validation\n- **{stats.get('valid_accounts', 0)}** accounts verified as active\n- **{stats.get('invalid_accounts', 0)}** accounts not found or deleted\n\n### Notion Sync\n- **{stats.get('added_to_notion', 0)}** new entries added successfully\n- **{stats.get('failed_to_add', 0)}** entries failed to add\n\n\"\"\"\n    \n    # Add errors if any\n    if stats.get('errors'):\n        report += \"## Errors\\n\\n\"\n        for error in stats['errors']:\n            report += f\"- {error}\\n\"\n    \n    # Add recommendations\n    report += \"\"\"\n## Next Steps\n\n1. ‚úÖ Review new entries in your Notion database\n2. üìù Fill in Business Type, Payment System, and Amount fields\n3. üéØ Update Status as you reach out to leads\n4. üîÑ Re-run sync to add more leads\n\n## Notes\n\n- All new entries are set to status \"Didn't Approach\"\n- Instagram validation uses HTTP requests (no API required)\n- Duplicate detection prevents re-adding existing entries\n- Check `validation_results/` for detailed JSON logs\n\"\"\"\n    \n    with open(output_path, 'w', encoding='utf-8') as f:\n        f.write(report)\n    \n    logging.info(f\"Sync report saved to: {output_path}\")\n\n\ndef print_summary(stats: Dict):\n    \"\"\"\n    Print summary to console.\n    \n    Args:\n        stats: Statistics dictionary\n    \"\"\"\n    print(\"\\n\" + \"=\"*70)\n    print(\"SYNC SUMMARY\")\n    print(\"=\"*70)\n    print(f\"Total usernames:        {stats.get('total_input', 0)}\")\n    print(f\"Batch duplicates:       {stats.get('duplicates_batch', 0)}\")\n    print(f\"Notion duplicates:      {stats.get('duplicates_notion', 0)}\")\n    print(f\"Valid accounts:         {stats.get('valid_accounts', 0)}\")\n    print(f\"Invalid accounts:       {stats.get('invalid_accounts', 0)}\")\n    print(f\"Added to Notion:        {stats.get('added_to_notion', 0)} ‚úì\")\n    print(f\"Failed to add:          {stats.get('failed_to_add', 0)}\")\n    print(\"=\"*70)\n    \n    if stats.get('added_to_notion', 0) > 0:\n        print(f\"\\nüéâ Successfully added {stats['added_to_notion']} new lead(s) to Notion!\")\n    elif stats.get('duplicates_notion', 0) > 0:\n        print(f\"\\n‚ÑπÔ∏è  All accounts already exist in Notion (no new entries added)\")\n    else:\n        print(f\"\\n‚ö†Ô∏è  No accounts were added to Notion\")\n\n\ndef main() -> int:\n    \"\"\"\n    Main application entry point.\n    \n    Returns:\n        Exit code (0 = success, 1 = error)\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Validate Instagram usernames and sync to Notion database\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # Standard workflow\n  python leads_to_notion.py\n\n  # Custom input file\n  python leads_to_notion.py --input custom_leads.txt\n\n  # Dry run (preview only)\n  python leads_to_notion.py --dry-run\n\n  # Skip validation, trust extraction\n  python leads_to_notion.py --skip-validation\n\n  # Verbose output\n  python leads_to_notion.py --verbose\n        \"\"\"\n    )\n    \n    parser.add_argument(\n        '--input',\n        type=Path,\n        default=Path.home() / 'Desktop' / 'leads' / 'verified_usernames.md',\n        help='Input file with usernames (default: ~/Desktop/leads/verified_usernames.md)'\n    )\n    \n    parser.add_argument(\n        '--output',\n        type=Path,\n        default=Path('validation_results'),\n        help='Output directory for results (default: ./validation_results)'\n    )\n    \n    parser.add_argument(\n        '--skip-validation',\n        action='store_true',\n        help='Skip Instagram validation, only add to Notion'\n    )\n    \n    parser.add_argument(\n        '--skip-notion',\n        action='store_true',\n        help='Only validate, do not sync to Notion'\n    )\n    \n    parser.add_argument(\n        '--delay',\n        type=float,\n        default=2.0,\n        help='Delay between Instagram requests in seconds (default: 2.0)'\n    )\n    \n    parser.add_argument(\n        '--dry-run',\n        action='store_true',\n        help='Preview changes without modifying Notion'\n    )\n    \n    parser.add_argument(\n        '--force-add',\n        action='store_true',\n        help='Skip duplicate checks (use with caution!)'\n    )\n    \n    parser.add_argument(\n        '--verbose',\n        action='store_true',\n        help='Enable debug logging'\n    )\n    \n    args = parser.parse_args()\n    \n    # Setup logging\n    setup_logging(args.verbose)\n    logger = logging.getLogger(__name__)\n    \n    print(\"\\n\" + \"=\"*70)\n    print(\"Instagram to Notion Sync\")\n    print(\"=\"*70 + \"\\n\")\n    \n    # Load environment variables\n    load_dotenv()\n    notion_token = os.getenv(\"NOTION_TOKEN\")\n    notion_db_id = os.getenv(\"NOTION_DATABASE_ID\")\n    \n    if not notion_token or not notion_db_id:\n        logger.error(\"Missing environment variables\")\n        print(\"‚ùå Error: NOTION_TOKEN and NOTION_DATABASE_ID must be set in .env\")\n        print(\"\\nCreate a .env file with:\")\n        print(\"  NOTION_TOKEN=your_integration_token\")\n        print(\"  NOTION_DATABASE_ID=your_database_id\")\n        print(\"\\nSee NOTION_SETUP.md for setup instructions\")\n        return 1\n    \n    # Statistics tracking\n    stats = {\n        'total_input': 0,\n        'duplicates_batch': 0,\n        'duplicates_notion': 0,\n        'validated': 0,\n        'valid_accounts': 0,\n        'invalid_accounts': 0,\n        'added_to_notion': 0,\n        'failed_to_add': 0,\n        'errors': []\n    }\n    \n    try:\n        # Step 1: Load usernames\n        logger.info(f\"Loading usernames from: {args.input}\")\n        usernames = load_usernames_from_markdown(args.input)\n        stats['total_input'] = len(usernames)\n        \n        if not usernames:\n            logger.warning(\"No usernames found in input file\")\n            print(\"‚ö†Ô∏è  No usernames found in input file\")\n            return 0\n        \n        print(f\"üìÇ Loaded {len(usernames)} username(s)\\n\")\n        \n        # Step 2: Remove batch duplicates\n        logger.info(\"Checking for batch duplicates...\")\n        usernames, batch_dupes = deduplicate_batch(usernames)\n        stats['duplicates_batch'] = batch_dupes\n        \n        if batch_dupes > 0:\n            print(f\"üîç Removed {batch_dupes} duplicate(s) from batch\\n\")\n        \n        # Step 3: Initialize Notion manager\n        if not args.skip_notion:\n            logger.info(\"Connecting to Notion...\")\n            notion = NotionDatabaseManager(notion_token, notion_db_id)\n            db_info = notion.get_database_info()\n            print(f\"üóÑÔ∏è  Connected to: {db_info.get('title', 'Database')}\\n\")\n            \n            # Step 4: Check Notion duplicates\n            if not args.force_add:\n                logger.info(\"Fetching existing entries from Notion...\")\n                existing_usernames = notion.get_all_existing_usernames()\n                \n                # Filter out duplicates\n                before_filter = len(usernames)\n                usernames = [u for u in usernames if u.lower() not in existing_usernames]\n                notion_dupes = before_filter - len(usernames)\n                stats['duplicates_notion'] = notion_dupes\n                \n                if notion_dupes > 0:\n                    print(f\"üîç Found {notion_dupes} username(s) already in Notion (skipped)\\n\")\n        \n        if not usernames:\n            logger.info(\"All usernames are duplicates\")\n            print(\"‚ÑπÔ∏è  All usernames already exist in the database\")\n            print_summary(stats)\n            return 0\n        \n        print(f\"‚ú® Processing {len(usernames)} new username(s)\\n\")\n        \n        # Step 5: Validate on Instagram\n        valid_accounts = []\n        \n        if args.skip_validation:\n            logger.info(\"Skipping Instagram validation (--skip-validation flag)\")\n            print(\"‚ö° Skipping validation (trusting extraction results)\\n\")\n            \n            # Create validation results without actual validation\n            valid_accounts = [\n                {'username': u, 'url': f\"https://instagram.com/{u}\", 'exists': True}\n                for u in usernames\n            ]\n            stats['validated'] = len(usernames)\n            stats['valid_accounts'] = len(usernames)\n        else:\n            logger.info(\"Starting Instagram validation...\")\n            print(\"üîé Validating accounts on Instagram...\\n\")\n            \n            with InstagramValidator(delay_between_requests=args.delay) as validator:\n                validation_results = validator.validate_batch(usernames)\n                stats['validated'] = len(validation_results)\n                \n                # Filter to valid accounts only\n                for result in validation_results:\n                    if result['exists']:\n                        valid_accounts.append(result)\n                        print(f\"  ‚úì @{result['username']}\")\n                    else:\n                        stats['invalid_accounts'] += 1\n                        error = result.get('error', 'Unknown')\n                        print(f\"  ‚úó @{result['username']} - {error}\")\n                \n                stats['valid_accounts'] = len(valid_accounts)\n                \n                # Save validation results\n                save_validation_results(validation_results, args.output)\n        \n        if not valid_accounts:\n            logger.warning(\"No valid accounts to add\")\n            print(\"\\n‚ö†Ô∏è  No valid accounts found to add to Notion\")\n            print_summary(stats)\n            return 0\n        \n        print(f\"\\n‚úÖ {len(valid_accounts)} valid account(s) ready to add\\n\")\n        \n        # Step 6: Add to Notion\n        if args.skip_notion:\n            logger.info(\"Skipping Notion sync (--skip-notion flag)\")\n            print(\"‚ö° Skipping Notion sync (--skip-notion flag)\")\n        elif args.dry_run:\n            logger.info(\"Dry run mode - no changes will be made\")\n            print(\"üîç DRY RUN MODE - Previewing what would be added:\\n\")\n            for account in valid_accounts:\n                print(f\"  ‚Ä¢ @{account['username']} ‚Üí {account['url']}\")\n            print(f\"\\n[DRY RUN] Would add {len(valid_accounts)} account(s) to Notion\")\n        else:\n            logger.info(\"Adding accounts to Notion...\")\n            print(\"üì§ Syncing to Notion...\\n\")\n            \n            sync_stats = notion.batch_create_pages(valid_accounts, skip_duplicates=False)\n            stats['added_to_notion'] = sync_stats['created']\n            stats['failed_to_add'] = sync_stats['failed']\n            stats['errors'] = sync_stats.get('errors', [])\n        \n        # Step 7: Generate reports\n        if not args.dry_run and not args.skip_notion:\n            report_path = Path.home() / 'Desktop' / 'leads' / 'notion_sync_report.md'\n            report_path.parent.mkdir(exist_ok=True)\n            generate_sync_report(stats, report_path)\n        \n        # Print summary\n        print_summary(stats)\n        \n        if not args.dry_run and not args.skip_notion:\n            print(f\"\\nüìä Report saved to: ~/Desktop/leads/notion_sync_report.md\")\n            print(f\"üìã Details saved to: {args.output}/\\n\")\n        \n        logger.info(\"Sync completed successfully\")\n        return 0\n    \n    except FileNotFoundError as e:\n        logger.error(f\"File not found: {e}\")\n        print(f\"\\n‚ùå Error: {e}\")\n        return 1\n    \n    except KeyboardInterrupt:\n        logger.warning(\"Operation cancelled by user\")\n        print(\"\\n\\n‚ö†Ô∏è  Operation cancelled by user\")\n        return 1\n    \n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\", exc_info=True)\n        print(f\"\\n‚ùå Error: {e}\")\n        print(\"Check logs in validation_results/ for details\")\n        return 1\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n