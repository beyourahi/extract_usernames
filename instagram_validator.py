"""\nInstagram Username Validator\n\nValidates Instagram usernames by making HTTP requests to profile URLs.\nImplements retry logic, rate limiting, and comprehensive error handling.\n\nAuthor: Rahi Khan (Dropout Studio)\nLicense: MIT\n"""\n\nimport time\nimport logging\nfrom typing import Dict, List, Optional\nfrom urllib.parse import quote\n\nimport requests\nfrom requests.adapters import HTTPAdapter\nfrom urllib3.util.retry import Retry\nfrom tenacity import (\n    retry,\n    stop_after_attempt,\n    wait_exponential,\n    retry_if_exception_type\n)\n\n\nclass InstagramValidator:\n    \"\"\"\n    Validates Instagram usernames via HTTP requests.\n    \n    Features:\n    - HTTP-based validation (no Instagram API required)\n    - Automatic retry with exponential backoff\n    - Rate limiting to avoid blocks\n    - Session pooling for performance\n    \n    Example:\n        >>> validator = InstagramValidator(delay_between_requests=2.0)\n        >>> result = validator.validate_username(\"nike\")\n        >>> print(result)\n        {'username': 'nike', 'exists': True, 'url': 'https://instagram.com/nike', ...}\n        >>> validator.close()\n    \"\"\"\n    \n    BASE_URL = \"https://www.instagram.com\"\n    \n    # User-Agent that mimics a real browser to avoid blocks\n    USER_AGENTS = [\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n        \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\"\n    ]\n    \n    def __init__(self, delay_between_requests: float = 2.0):\n        \"\"\"\n        Initialize the Instagram validator.\n        \n        Args:\n            delay_between_requests: Seconds to wait between requests (default: 2.0)\n        \"\"\"\n        self.delay = delay_between_requests\n        self.session = self._create_session()\n        self.logger = logging.getLogger(__name__)\n        self._last_request_time = 0\n        self._request_count = 0\n        \n    def _create_session(self) -> requests.Session:\n        \"\"\"\n        Create a requests session with retry logic and connection pooling.\n        \n        Returns:\n            Configured requests.Session\n        \"\"\"\n        session = requests.Session()\n        \n        # Configure retry strategy\n        retry_strategy = Retry(\n            total=3,  # Total number of retries\n            backoff_factor=1,  # Wait 1, 2, 4 seconds between retries\n            status_forcelist=[429, 500, 502, 503, 504],  # Retry on these status codes\n            allowed_methods=[\"GET\"]  # Only retry GET requests\n        )\n        \n        adapter = HTTPAdapter(\n            max_retries=retry_strategy,\n            pool_connections=10,\n            pool_maxsize=10\n        )\n        \n        session.mount(\"http://\", adapter)\n        session.mount(\"https://\", adapter)\n        \n        return session\n    \n    def _sanitize_username(self, username: str) -> str:\n        \"\"\"\n        Sanitize Instagram username by removing unwanted characters.\n        \n        Args:\n            username: Raw username string\n            \n        Returns:\n            Sanitized username\n        \"\"\"\n        # Remove @ symbol, whitespace, and special characters\n        username = username.strip().lstrip('@')\n        username = ''.join(c for c in username if c.isalnum() or c in '._')\n        return username.lower()\n    \n    def _enforce_rate_limit(self):\n        \"\"\"Enforce rate limiting between requests.\"\"\"\n        if self._last_request_time > 0:\n            elapsed = time.time() - self._last_request_time\n            if elapsed < self.delay:\n                time.sleep(self.delay - elapsed)\n        self._last_request_time = time.time()\n    \n    @retry(\n        stop=stop_after_attempt(3),\n        wait=wait_exponential(multiplier=1, min=2, max=10),\n        retry=retry_if_exception_type((requests.RequestException, requests.Timeout)),\n        reraise=True\n    )\n    def _make_request(self, username: str) -> requests.Response:\n        \"\"\"\n        Make HTTP request to Instagram profile with retry logic.\n        \n        Args:\n            username: Sanitized Instagram username\n            \n        Returns:\n            requests.Response object\n            \n        Raises:\n            requests.RequestException: If request fails after retries\n        \"\"\"\n        url = f\"{self.BASE_URL}/{quote(username)}/\"\n        \n        headers = {\n            \"User-Agent\": self.USER_AGENTS[self._request_count % len(self.USER_AGENTS)],\n            \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n            \"Accept-Language\": \"en-US,en;q=0.5\",\n            \"Accept-Encoding\": \"gzip, deflate, br\",\n            \"DNT\": \"1\",\n            \"Connection\": \"keep-alive\",\n            \"Upgrade-Insecure-Requests\": \"1\"\n        }\n        \n        response = self.session.get(\n            url,\n            headers=headers,\n            timeout=10,\n            allow_redirects=True\n        )\n        \n        return response\n    \n    def validate_username(self, username: str) -> Dict[str, any]:\n        \"\"\"\n        Validate a single Instagram username.\n        \n        Args:\n            username: Instagram username to validate\n            \n        Returns:\n            Dictionary with validation results:\n            {\n                'username': str,          # Sanitized username\n                'exists': bool,           # True if account exists\n                'url': str,               # Full Instagram URL\n                'status_code': int,       # HTTP status code\n                'error': Optional[str]    # Error message if validation failed\n            }\n        \"\"\"\n        sanitized = self._sanitize_username(username)\n        url = f\"{self.BASE_URL}/{sanitized}/\"\n        \n        result = {\n            'username': sanitized,\n            'exists': False,\n            'url': url,\n            'status_code': None,\n            'error': None\n        }\n        \n        if not sanitized:\n            result['error'] = \"Invalid username format\"\n            self.logger.warning(f\"Invalid username format: {username}\")\n            return result\n        \n        try:\n            # Enforce rate limiting\n            self._enforce_rate_limit()\n            \n            # Make request\n            response = self._make_request(sanitized)\n            result['status_code'] = response.status_code\n            \n            # Check if account exists\n            # 200 = exists, 404 = not found, 302+ = redirect (usually to login for private/deleted)\n            if response.status_code == 200:\n                # Additional check: ensure we're not redirected to login page\n                if '/accounts/login' not in response.url:\n                    result['exists'] = True\n                    self.logger.info(f\"✓ Valid account: @{sanitized}\")\n                else:\n                    result['error'] = \"Account requires login (private or deleted)\"\n                    self.logger.info(f\"✗ Private/deleted: @{sanitized}\")\n            elif response.status_code == 404:\n                result['error'] = \"Account not found\"\n                self.logger.info(f\"✗ Not found: @{sanitized}\")\n            else:\n                result['error'] = f\"Unexpected status code: {response.status_code}\"\n                self.logger.warning(f\"? Unexpected response for @{sanitized}: {response.status_code}\")\n            \n            self._request_count += 1\n            \n        except requests.Timeout:\n            result['error'] = \"Request timeout\"\n            self.logger.error(f\"Timeout validating @{sanitized}\")\n            \n        except requests.RequestException as e:\n            result['error'] = f\"Request failed: {str(e)}\"\n            self.logger.error(f\"Request error for @{sanitized}: {e}\")\n            \n        except Exception as e:\n            result['error'] = f\"Unexpected error: {str(e)}\"\n            self.logger.error(f\"Unexpected error for @{sanitized}: {e}\", exc_info=True)\n        \n        return result\n    \n    def validate_batch(self, usernames: List[str]) -> List[Dict]:\n        \"\"\"\n        Validate a batch of Instagram usernames.\n        \n        Args:\n            usernames: List of Instagram usernames\n            \n        Returns:\n            List of validation result dictionaries\n        \"\"\"\n        results = []\n        total = len(usernames)\n        \n        self.logger.info(f\"Starting validation of {total} usernames\")\n        \n        for i, username in enumerate(usernames, 1):\n            self.logger.info(f\"[{i}/{total}] Validating @{username}...\")\n            result = self.validate_username(username)\n            results.append(result)\n        \n        # Summary statistics\n        valid_count = sum(1 for r in results if r['exists'])\n        invalid_count = total - valid_count\n        \n        self.logger.info(f\"Validation complete: {valid_count} valid, {invalid_count} invalid\")\n        \n        return results\n    \n    def close(self):\n        \"\"\"Close the requests session.\"\"\"\n        if self.session:\n            self.session.close()\n            self.logger.debug(\"Instagram validator session closed\")\n    \n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        self.close()\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Configure logging\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n    )\n    \n    # Test usernames\n    test_usernames = [\n        \"nike\",\n        \"instagram\",\n        \"this_account_definitely_does_not_exist_12345\",\n        \"@cristiano\",  # Test @ removal\n        \"  google  \"  # Test whitespace\n    ]\n    \n    print(\"Instagram Username Validator - Test Run\")\n    print(\"=\" * 60)\n    \n    with InstagramValidator(delay_between_requests=2.0) as validator:\n        results = validator.validate_batch(test_usernames)\n        \n        print(\"\\nResults:\")\n        print(\"-\" * 60)\n        for result in results:\n            status = \"✓ EXISTS\" if result['exists'] else \"✗ INVALID\"\n            error = f\" ({result['error']})\" if result['error'] else \"\"\n            print(f\"{status:12} @{result['username']:30} {error}\")\n        print(\"-\" * 60)\n